# Day 16 challenge: Packet Decoder
# Author: Nathan Bloom nxb4951@rit.edu
import argparse
from typing import Union


class Packet:
    version: int
    type: int
    payload: Union[str, list]
    pl_length: str

    def __init__(self, version, p_type, payload, pl_length=None):
        self.version = version
        self.type = p_type
        self.payload = payload
        self.pl_length = pl_length

    def __repr__(self):
        return f"Packet(version={self.version}, type={self.type}, " \
               f"payload={(self.interpret_payload() if self.type == 4 else self.payload)})"

    def interpret_payload(self):
        if self.type == 4:
            return int(self.payload, 2)
        else:
            return self.payload

    def value(self):
        if self.type == 4:  # literal
            return int(self.payload, 2)
        elif self.type == 0:  # sum
            return sum([i.value() for i in self.payload])
        elif self.type == 1:  # product
            product = 1
            for i in self.payload:
                product *= i.value()
            return product
        elif self.type == 2:  # min
            return min([i.value() for i in self.payload])
        elif self.type == 3:  # max
            return max([i.value() for i in self.payload])
        elif self.type == 5:  # gt
            return 1 if self.payload[0].value() > self.payload[1].value() else 0
        elif self.type == 6:  # lt
            return 1 if self.payload[0].value() < self.payload[1].value() else 0
        elif self.type == 7: # eq
            return 1 if self.payload[0].value() == self.payload[1].value() else 0


def version_sum(packet):
    # print(packet)
    if packet.type == 4:
        return packet.version
    else:
        return sum([version_sum(i) for i in packet.payload]) + packet.version


def parse_packet(everything, count=None):
    results = []  # the packets that get generated by this function

    # everything = everything.lstrip("0")
    while len(everything) > 6 and "1" in everything and (not count or len(results) < count):
        packet_version, everything = int(everything[:3], 2), everything[3:]
        packet_type, everything = int(everything[:3], 2), everything[3:]

        if packet_type == 4:  # literal value
            groups = []
            while True:
                payload_group = everything[:5]
                groups.append(payload_group)
                everything = everything[5:]
                if payload_group[0] == "0":
                    break
            results.append(Packet(packet_version, packet_type, "".join([i[1:] for i in groups])))
        elif everything[0] == "0":
            everything = everything[1:]
            sub_length, everything = int(everything[:15], 2), everything[15:]

            payload, _ = parse_packet(everything[:sub_length])
            everything = everything[sub_length:]

            results.append(Packet(packet_version, packet_type, payload))
        elif everything[0] == "1":
            everything = everything[1:]
            sub_count, everything = int(everything[:11], 2), everything[11:]

            payload, new_everything = parse_packet(everything, sub_count)
            everything = new_everything
            results.append(Packet(packet_version, packet_type, payload))
    if count is not None:  # in case we only care about a certain number of results
        return results[:count], everything
    return results, everything


def part1(input_file):
    everything = ""
    with open(input_file) as input_file:
        for line in input_file:
            assert everything == ""  # i'm not handling multiple lines since it doesn't look like i'll have to
            everything = bin(int(line.strip(), 16))[2:]
            start_check = 0
            while True:
                if line[start_check] == "0":
                    start_check += 1
                    everything = "0000" + everything
                else:
                    break

    everything = "0" * ((4 - (len(everything) % 4)) % 4) + everything  # pad it out to make sure it's a multiple of 4

    packet = parse_packet(everything)[0][0]
    # print(packet)
    return version_sum(packet)


def part2(input_file):
    everything = ""
    with open(input_file) as input_file:
        for line in input_file:
            assert everything == ""  # i'm not handling multiple lines since it doesn't look like i'll have to
            everything = bin(int(line.strip(), 16))[2:]
            start_check = 0
            while True:
                if line[start_check] == "0":
                    start_check += 1
                    everything = "0000" + everything
                else:
                    break

    everything = "0" * ((4 - (len(everything) % 4)) % 4) + everything  # pad it out to make sure it's a multiple of 4

    packet = parse_packet(everything)[0][0]
    # print(packet)
    return packet.value()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Advent of Code Day 16 challenge: Packet Decoder")
    # argparser setup
    parser.add_argument("input", type=str, help="A file containing the BITS packet to decode")
    args = parser.parse_args()

    result1 = part1(args.input)
    print(f"Part 1 result: {result1}")
    result2 = part2(args.input)
    print(f"Part 2 result: {result2}")
